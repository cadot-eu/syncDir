#!/bin/bash

# syncDir avec chiffrement AES (compatible Android)

LOCAL_USER=$(whoami)
LOCAL_BASE="/home/${LOCAL_USER}"
CONFIG_FILE="${LOCAL_BASE}/.syncdir_aes.conf"
LOCK_DIR="/tmp/syncDir_locks"
LOG_DIR="${LOCAL_BASE}/.local/log/syncDir"

if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m'
else
    RED=''; GREEN=''; YELLOW=''; NC=''
fi

log_info() {
    echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
    [ -d "$LOG_DIR" ] && echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_DIR/syncDir_aes.log"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1"
}

mkdir -p "$LOCK_DIR" "$LOG_DIR" 2>/dev/null

# Aide
if [ "$1" == "--help" ] || [ $# -lt 1 ]; then
    echo "syncDir_aes - Synchronisation avec chiffrement AES (compatible Android)"
    echo "Usage: syncDir_aes <repertoire> [--maitre|--reset]"
    exit 0
fi

DIR_NAME="$1"
IS_MASTER=false
IS_RESET=false

shift
while [ $# -gt 0 ]; do
    case "$1" in
        --maitre|maitre) IS_MASTER=true; shift ;;
        --reset|reset) IS_RESET=true; shift ;;
        *) log_error "Option invalide: $1"; exit 1 ;;
    esac
done

# Configuration
if [ ! -f "$CONFIG_FILE" ]; then
    echo "Configuration"
    read -p "Serveur distant : " remote_host
    read -p "Utilisateur root [root] : " remote_root
    remote_root=${remote_root:-root}
    read -sp "Mot de passe chiffrement : " crypt_password
    echo ""
    
    cat > "$CONFIG_FILE" <<EOF
REMOTE_HOST="$remote_host"
REMOTE_ROOT="$remote_root"
CRYPT_PASSWORD="$crypt_password"
EOF
    chmod 600 "$CONFIG_FILE"
fi

source "$CONFIG_FILE"

REMOTE_USER="${LOCAL_USER}Sync"
LOCAL_DIR="${LOCAL_BASE}/${DIR_NAME}"
DIR_NAME_SAFE="${DIR_NAME//\//_}"
LOCK_FILE="${LOCK_DIR}/${DIR_NAME_SAFE}.lock"

if [ ! -d "$LOCAL_DIR" ]; then
    log_error "Répertoire inexistant: $LOCAL_DIR"
    exit 1
fi

# Verrou
if [ -f "$LOCK_FILE" ]; then
    pid=$(cat "$LOCK_FILE")
    if kill -0 "$pid" 2>/dev/null; then
        log_warn "Sync en cours (PID: $pid)"
        exit 0
    fi
    rm -f "$LOCK_FILE"
fi

echo $$ > "$LOCK_FILE"
trap "rm -f $LOCK_FILE" EXIT

# SSH key
if [ ! -f "${LOCAL_BASE}/.ssh/id_rsa" ]; then
    ssh-keygen -t rsa -b 4096 -f "${LOCAL_BASE}/.ssh/id_rsa" -N "" -C "${LOCAL_USER}@syncDir"
fi

# Utilisateur distant
if ! ssh "${REMOTE_ROOT}@${REMOTE_HOST}" "id ${REMOTE_USER} &>/dev/null"; then
    log_info "Création ${REMOTE_USER}..."
    ssh "${REMOTE_ROOT}@${REMOTE_HOST}" bash <<EOFREMOTE
sudo useradd -m -s /bin/bash ${REMOTE_USER}
sudo mkdir -p /home/${REMOTE_USER}/.ssh /home/${REMOTE_USER}/encrypted
sudo chmod 700 /home/${REMOTE_USER}/.ssh
sudo chown -R ${REMOTE_USER}:${REMOTE_USER} /home/${REMOTE_USER}
EOFREMOTE
    
    cat "${LOCAL_BASE}/.ssh/id_rsa.pub" | ssh "${REMOTE_ROOT}@${REMOTE_HOST}" \
        "sudo tee -a /home/${REMOTE_USER}/.ssh/authorized_keys > /dev/null && \
         sudo chmod 600 /home/${REMOTE_USER}/.ssh/authorized_keys && \
         sudo chown ${REMOTE_USER}:${REMOTE_USER} /home/${REMOTE_USER}/.ssh/authorized_keys"
fi

remote_encrypted="/home/${REMOTE_USER}/encrypted/${DIR_NAME}"
local_encrypted="${LOCAL_DIR}/.encrypted_cache"

mkdir -p "$local_encrypted"

ssh "${REMOTE_USER}@${REMOTE_HOST}" "mkdir -p ${remote_encrypted}" 2>/dev/null || \
    ssh "${REMOTE_ROOT}@${REMOTE_HOST}" "sudo mkdir -p ${remote_encrypted} && sudo chown -R ${REMOTE_USER}:${REMOTE_USER} ${remote_encrypted}"

if [ "$IS_RESET" = true ]; then
    log_warn "Reset"
    ssh "${REMOTE_ROOT}@${REMOTE_HOST}" "sudo rm -rf ${remote_encrypted}/*"
    rm -rf "$local_encrypted"/*
fi

log_info "===== Synchronisation: $DIR_NAME ====="

# Dériver clé AES-256 depuis le mot de passe
KEY=$(echo -n "$CRYPT_PASSWORD" | sha256sum | head -c 64)

if [ "$IS_MASTER" = true ]; then
    log_info "Mode MAITRE"
    
    log_info "[1/2] Chiffrement AES..."
    find "$LOCAL_DIR" -type f ! -path "*/.encrypted_cache/*" | while read -r file; do
        rel_path="${file#$LOCAL_DIR/}"
        encrypted_file="${local_encrypted}/${rel_path}.enc"
        
        mkdir -p "$(dirname "$encrypted_file")"
        
        if [ ! -f "$encrypted_file" ] || [ "$file" -nt "$encrypted_file" ]; then
            openssl enc -aes-256-cbc -salt -in "$file" -out "$encrypted_file" -k "$CRYPT_PASSWORD" 2>/dev/null && \
                log_info "  ✓ $rel_path"
        fi
    done
    
    log_info "[2/2] Upload..."
    rsync -avz --delete -e "ssh" "${local_encrypted}/" "${REMOTE_USER}@${REMOTE_HOST}:${remote_encrypted}/"
    
else
    log_info "Mode BIDIRECTIONNEL"
    
    log_info "[1/4] Chiffrement local..."
    find "$LOCAL_DIR" -type f ! -path "*/.encrypted_cache/*" | while read -r file; do
        rel_path="${file#$LOCAL_DIR/}"
        encrypted_file="${local_encrypted}/${rel_path}.enc"
        
        mkdir -p "$(dirname "$encrypted_file")"
        
        if [ ! -f "$encrypted_file" ] || [ "$file" -nt "$encrypted_file" ]; then
            openssl enc -aes-256-cbc -salt -in "$file" -out "$encrypted_file" -k "$CRYPT_PASSWORD" 2>/dev/null && \
                log_info "  ✓ $rel_path"
        fi
    done
    
    log_info "[2/4] Download..."
    rsync -avz -e "ssh" "${REMOTE_USER}@${REMOTE_HOST}:${remote_encrypted}/" "${local_encrypted}/"
    
    log_info "[3/4] Déchiffrement..."
    find "$local_encrypted" -type f -name "*.enc" | while read -r encrypted_file; do
        rel_path="${encrypted_file#$local_encrypted/}"
        rel_path="${rel_path%.enc}"
        decrypted_file="${LOCAL_DIR}/${rel_path}"
        
        mkdir -p "$(dirname "$decrypted_file")"
        
        if [ ! -f "$decrypted_file" ] || [ "$encrypted_file" -nt "$decrypted_file" ]; then
            openssl enc -aes-256-cbc -d -in "$encrypted_file" -out "$decrypted_file" -k "$CRYPT_PASSWORD" 2>/dev/null && \
                log_info "  ✓ $rel_path"
        fi
    done
    
    log_info "[4/4] Upload..."
    rsync -avz -e "ssh" "${local_encrypted}/" "${REMOTE_USER}@${REMOTE_HOST}:${remote_encrypted}/"
fi

ssh "${REMOTE_ROOT}@${REMOTE_HOST}" "sudo chown -R ${REMOTE_USER}:${REMOTE_USER} ${remote_encrypted}" 2>/dev/null

log_info "===== ✓ Terminé ====="
